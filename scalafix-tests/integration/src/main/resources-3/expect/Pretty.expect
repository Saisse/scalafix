[7:7..7:17]:      test/PrettyTest# => class PrettyTest extends Object { self: PrettyTest => +6 decls }
[8:3..8:14]:      *[Int]
[8:3..8:7]:       *.apply[Int]
[8:3..8:3]:       test/PrettyTest#`<init>`(). => primary ctor <init>(): PrettyTest
[10:10..10:11]:   intWrapper(*)
[11:10..11:11]:   intWrapper(*)
[15:10..15:16]:   *.apply[Inclusive]
[15:10..15:26]:   *(global)
[15:17..15:18]:   intWrapper(*)
[16:10..16:16]:   *.apply[Inclusive]
[16:10..16:32]:   *(global)
[16:17..16:18]:   intWrapper(*)
[21:3..21:3]:     test/PrettyTest#Inner#`<init>`(). => primary ctor <init>(): Inner
[21:9..21:14]:    test/PrettyTest#Inner# => class Inner extends Object { self: Inner => +1 decls }
[22:7..22:8]:     test/PrettyTest#a. => val method aPrettyTest
[23:7..23:8]:     test/PrettyTest#b. => val method ba.Inner
[25:3..25:9]:     *.apply[Object {
                    local4 => abstract method foo(a: Int): Int
                    local5 => abstract method bar(a: Int): Int
                  }]
[31:3..31:9]:     *.apply[Int & String]
[39:7..39:10]:    test/ann# => class ann[T] extends Annotation with StaticAnnotation { self: ann[T] => +3 decls }
[39:10..39:10]:   test/ann#`<init>`(). => primary ctor <init>[T](x: T): ann[T]
[39:11..39:12]:   test/ann#[T] => typeparam T
[39:14..39:15]:   test/ann#x. => private[this] val method xT
[40:7..40:11]:    test/ann1# => class ann1 extends Annotation with StaticAnnotation { self: ann1 => +1 decls }
[40:20..40:20]:   test/ann1#`<init>`(). => primary ctor <init>(): ann1
[41:7..41:11]:    test/ann2# => class ann2 extends Annotation with StaticAnnotation { self: ann2 => +1 decls }
[41:20..41:20]:   test/ann2#`<init>`(). => primary ctor <init>(): ann2
[43:1..43:1]:     test/B#`<init>`(). => primary ctor <init>(): B
[43:7..43:8]:     test/B# => class B extends Object { self: B => +1 decls }
[45:1..45:1]:     test/C#`<init>`(). => primary ctor <init>(): C
[45:7..45:8]:     test/C# => class C extends Object { self: C => +1 decls }
[47:7..47:8]:     test/P# => class P extends Object { self: P => +8 decls }
[48:3..48:3]:     test/P#C#`<init>`(). => primary ctor <init>(): C
[48:3..48:3]:     test/P#`<init>`(). => primary ctor <init>(): P
[48:9..48:10]:    test/P#C# => class C extends Object { self: C => +1 decls }
[49:3..49:3]:     test/P#X#`<init>`(). => primary ctor <init>(): X
[49:9..49:10]:    test/P#X# => class X extends Object { self: X => +1 decls }
[50:7..50:8]:     test/P#x. => val method xX
[53:7..53:8]:     test/T# => class T extends Object { self: T => +8 decls }
[54:3..54:3]:     test/T#C#`<init>`(). => primary ctor <init>(): C
[54:3..54:3]:     test/T#`<init>`(). => primary ctor <init>(): T
[54:9..54:10]:    test/T#C# => class C extends Object { self: C => +1 decls }
[55:3..55:3]:     test/T#X#`<init>`(). => primary ctor <init>(): X
[55:9..55:10]:    test/T#X# => class X extends Object { self: X => +1 decls }
[56:7..56:8]:     test/T#x. => val method xX
[59:8..59:12]:    test/Test. => final object Test extends Object { self: Test.type => +10 decls }
[60:9..60:10]:    test/Test.M# => class M extends Object { self: M => +2 decls }
[61:5..61:5]:     test/Test.M#`<init>`(). => primary ctor <init>(): M
[61:9..61:10]:    test/Test.M#m(). => method m=> Int
[64:9..64:10]:    test/Test.N# => trait N extends Object { self: N => +2 decls }
[65:5..65:5]:     test/Test.N#`<init>`(). => primary ctor <init>(): N
[65:9..65:10]:    test/Test.N#n(). => method n=> Int
[68:9..68:10]:    test/Test.C# => class C extends M { self: C => +42 decls }
[68:19..68:19]:   test/Test.C#`<init>`(). => primary ctor <init>(): C
[69:9..69:10]:    test/Test.C#p. => val method pP
[70:9..70:10]:    test/Test.C#x. => val method xp.X
[72:9..72:17]:    test/Test.C#typeRef1. => val method typeRef1C
[73:9..73:17]:    test/Test.C#typeRef2. => val method typeRef2p.C
[74:9..74:17]:    test/Test.C#typeRef3. => val method typeRef3T#C
[75:9..75:17]:    test/Test.C#typeRef4. => val method typeRef4List[Int]
[77:9..77:20]:    test/Test.C#singleType1. => val method singleType1x.type
[78:9..78:20]:    test/Test.C#singleType2. => val method singleType2p.x.type
[79:9..79:15]:    test/Test.C#Either. => val method EitherEither.type
[81:9..81:18]:    test/Test.C#thisType1. => val method thisType1C.this.type
[82:9..82:18]:    test/Test.C#thisType2. => val method thisType2C.this.type
[84:9..84:19]:    test/Test.C#superType1. => val method superType1Int
[85:9..85:19]:    test/Test.C#superType2. => val method superType2Int
[86:9..86:19]:    test/Test.C#superType3. => val method superType3Int
[88:9..88:22]:    test/Test.C#compoundType1. => val method compoundType1Object { def k=> Int }
[89:9..89:22]:    test/Test.C#compoundType2. => val method compoundType2M & N
[90:9..90:22]:    test/Test.C#compoundType3. => val method compoundType3M & N { def k=> Int }
[91:9..91:22]:    test/Test.C#compoundType4. => val method compoundType4Object
[92:9..92:22]:    test/Test.C#compoundType5. => val method compoundType5M & N
[93:9..93:22]:    test/Test.C#compoundType6. => val method compoundType6M & N
[95:9..95:17]:    test/Test.C#annType1. => val method annType1T @ann[T]
[95:21..95:25]:   [Int]
[96:9..96:17]:    test/Test.C#annType2. => val method annType2T @ann1 @ann2
[98:9..98:25]:    test/Test.C#existentialType2. => val method existentialType2List[_] forSome { type _ }
[99:9..99:25]:    test/Test.C#existentialType3. => val method existentialType3Class[_] forSome { type _ }
[100:9..100:25]:  test/Test.C#existentialType4. => val method existentialType4Class[_] forSome { type _ }
[102:9..102:20]:  test/Test.C#typeLambda1(). => method typeLambda1[M[type _]]: Nothing
[102:21..102:22]: test/Test.C#typeLambda1().[M] => typeparam M[type _]
[105:12..105:26]: test/Test.C#ClassInfoType1. => final object ClassInfoType1 extends Object { self: ClassInfoType1.type => +1 decls }
[106:11..106:25]: test/Test.C#ClassInfoType2# => class ClassInfoType2 extends B { self: ClassInfoType2 => +2 decls }
[106:34..106:34]: test/Test.C#ClassInfoType2#`<init>`(). => primary ctor <init>(): ClassInfoType2
[106:42..106:43]: test/Test.C#ClassInfoType2#x(). => method x=> Int
[107:11..107:25]: test/Test.C#ClassInfoType3# => trait ClassInfoType3[T] extends Object { self: ClassInfoType3[T] => +2 decls }
[107:25..107:25]: test/Test.C#ClassInfoType3#`<init>`(). => primary ctor <init>[T](): ClassInfoType3[T]
[107:26..107:27]: test/Test.C#ClassInfoType3#[T] => typeparam T
[109:12..109:22]: test/Test.C#MethodType. => final object MethodType extends Object { self: MethodType.type => +7 decls }
[110:11..110:13]: test/Test.C#MethodType.x1(). => method x1=> Int
[111:11..111:13]: test/Test.C#MethodType.x2(). => method x2=> Int
[112:11..112:13]: test/Test.C#MethodType.m3(). => method m3=> Int
[113:11..113:13]: test/Test.C#MethodType.m4(). => method m4(): Int
[114:11..114:13]: test/Test.C#MethodType.m5(). => method m5(x: Int): Int
[114:14..114:15]: test/Test.C#MethodType.m5().(x) => param x: Int
[115:11..115:13]: test/Test.C#MethodType.m6(). => method m6[T](x: T): T
[115:14..115:15]: test/Test.C#MethodType.m6().[T] => typeparam T
[115:17..115:18]: test/Test.C#MethodType.m6().(x) => param x: T
[118:12..118:22]: test/Test.C#ByNameType. => final object ByNameType extends Object { self: ByNameType.type => +2 decls }
[119:11..119:13]: test/Test.C#ByNameType.m1(). => method m1(x: => Int): Int
[119:14..119:15]: test/Test.C#ByNameType.m1().(x) => param x: => Int
[122:16..122:28]: test/Test.C#RepeatedType# => case class RepeatedType extends Object with Product with Serializable { self: RepeatedType => +4 decls }
[122:28..122:28]: test/Test.C#RepeatedType#`<init>`(). => primary ctor <init>(val s: String*): RepeatedType
[122:29..122:30]: test/Test.C#RepeatedType#s. => val method sString*
[123:11..123:13]: test/Test.C#RepeatedType#m1(). => method m1(x: Int*): Int
[123:14..123:15]: test/Test.C#RepeatedType#m1().(x) => param x: Int*
[126:12..126:20]: test/Test.C#TypeType. => final object TypeType extends Object { self: TypeType.type => +6 decls }
[127:12..127:14]: test/Test.C#TypeType.T1# => type T1
[128:11..128:13]: test/Test.C#TypeType.m2(). => method m2[T2 = C]: Nothing
[128:14..128:16]: test/Test.C#TypeType.m2().[T2] => typeparam T2 = C
[129:11..129:13]: test/Test.C#TypeType.m3(). => method m3[M3[type _]]: Nothing
[129:14..129:16]: test/Test.C#TypeType.m3().[M3] => typeparam M3[type _]
[130:12..130:14]: test/Test.C#TypeType.T4# => type T4 = C
[131:12..131:14]: test/Test.C#TypeType.T5# => type T5[U] = U
[131:15..131:16]: test/Test.C#TypeType.T5#[U] => typeparam U
[135:10..135:17]: test/Test.Literal. => final object Literal extends Object { self: Literal.type => +12 decls }
[136:15..136:18]: test/Test.Literal.int. => final val method int1
[137:15..137:19]: test/Test.Literal.long. => final val method long1L
[138:15..138:20]: test/Test.Literal.float. => final val method float1.0f
[139:15..139:21]: test/Test.Literal.double. => final val method double2.0
[140:15..140:18]: test/Test.Literal.nil. => final val method nilNull
[141:15..141:19]: test/Test.Literal.char. => final val method char'a'
[142:15..142:21]: test/Test.Literal.string. => final val method string"a"
[143:15..143:19]: test/Test.Literal.bool. => final val method booltrue
[144:15..144:19]: test/Test.Literal.unit. => final val method unitUnit
[145:15..145:23]: test/Test.Literal.javaEnum. => final val method javaEnumLinkOption
[146:15..146:22]: test/Test.Literal.clazzOf. => final val method clazzOfOption[Int]